{"ast":null,"code":"import { e as jsonParse, l as lib, c as createCommonjsModule } from './fetch-deps.js';\n/**\r\n * Parses a given request/response body based on the `Content-Type` header.\r\n */\n\nfunction parseBody(body, headers) {\n  var _a;\n\n  if (body) {\n    // If the intercepted request's body has a JSON Content-Type\n    // parse it into an object, otherwise leave as-is.\n    const hasJsonContent = (_a = headers === null || headers === void 0 ? void 0 : headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('json');\n\n    if (hasJsonContent && typeof body !== 'object') {\n      return jsonParse(body) || body;\n    }\n\n    return body;\n  } // Return whatever falsey body value is given.\n\n\n  return body;\n}\n/**\r\n * Formats a mocked request for introspection in browser's console.\r\n */\n\n\nfunction prepareRequest(req) {\n  return Object.assign(Object.assign({}, req), {\n    headers: req.headers.getAllHeaders()\n  });\n}\n/**\r\n * Formats a mocked response for introspection in browser's console.\r\n */\n\n\nfunction prepareResponse(res) {\n  const responseHeaders = lib.listToHeaders(res.headers);\n  return Object.assign(Object.assign({}, res), {\n    // Parse a response JSON body for preview in the logs\n    body: parseBody(res.body, responseHeaders)\n  });\n}\n\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map(chunk => chunk.slice(0, 2)).map(chunk => chunk.padStart(2, '0')).join(':');\n}\n/**\r\n * Returns a HEX color for a given response status code number.\r\n */\n\n\nfunction getStatusCodeColor(status) {\n  if (status < 300) {\n    return '#69AB32';\n  }\n\n  if (status < 400) {\n    return '#F0BB4B';\n  }\n\n  return '#E95F5D';\n}\n/**\r\n * Converts a string path to a Regular Expression.\r\n * Transforms path parameters into named RegExp groups.\r\n */\n\n\nconst pathToRegExp = path => {\n  const pattern = path // Escape literal dots\n  .replace(/\\./g, '\\\\.') // Escape literal slashes\n  .replace(/\\//g, '/') // Escape literal question marks\n  .replace(/\\?/g, '\\\\?') // Ignore trailing slashes\n  .replace(/\\/+$/, '') // Replace wildcard with any zero-to-any character sequence\n  .replace(/\\*+/g, '.*') // Replace parameters with named capturing groups\n  .replace(/:([^\\d|^\\/][a-zA-Z0-9_]*(?=(?:\\/|\\\\.)|$))/g, (_, paramName) => `(?<${paramName}>[^\\/]+?)`) // Allow optional trailing slash\n  .concat('(\\\\/|$)');\n  return new RegExp(pattern, 'gi');\n};\n/**\r\n * Matches a given url against a path.\r\n */\n\n\nconst match = (path, url) => {\n  const expression = path instanceof RegExp ? path : pathToRegExp(path);\n  const match = expression.exec(url) || false; // Matches in strict mode: match string should equal to input (url)\n  // Otherwise loose matches will be considered truthy:\n  // match('/messages/:id', '/messages/123/users') // true\n\n  const matches = path instanceof RegExp ? !!match : !!match && match[0] === match.input;\n  return {\n    matches,\n    params: match && matches ? match.groups || null : null\n  };\n};\n\nvar getCleanUrl_1 = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getCleanUrl = void 0;\n  /**\n   * Removes query parameters and hashes from a given URL.\n   */\n\n  function getCleanUrl(url, isAbsolute) {\n    if (isAbsolute === void 0) {\n      isAbsolute = true;\n    }\n\n    return [isAbsolute && url.origin, url.pathname].filter(Boolean).join('');\n  }\n\n  exports.getCleanUrl = getCleanUrl;\n});\n/**\r\n * Returns an absolute URL based on the given relative URL, if possible.\r\n * Ignores regular expressions.\r\n */\n\nconst getAbsoluteUrl = mask => {\n  // Global `location` object doesn't exist in Node.\n  // Relative request predicate URL cannot become absolute.\n  const hasLocation = typeof location !== 'undefined';\n  return typeof mask === 'string' && mask.startsWith('/') ? `${hasLocation ? location.origin : ''}${mask}` : mask;\n};\n/**\r\n * Converts a given request handler mask into a URL, if given a valid URL string.\r\n */\n\n\nfunction getUrlByMask(mask) {\n  /**\r\n   * If a string mask contains an asterisk (wildcard), return it as-is.\r\n   * Converting a URL-like path string into an actual URL is misleading.\r\n   * @see https://github.com/mswjs/msw/issues/357\r\n   */\n  if (mask instanceof RegExp || mask.includes('*')) {\n    return mask;\n  }\n\n  try {\n    // Attempt to create a URL instance out of the mask string.\n    // Resolve mask to an absolute URL, because even a valid relative URL\n    // cannot be converted into the URL instance (required absolute URL only).\n    return new URL(getAbsoluteUrl(mask));\n  } catch (error) {\n    // Otherwise, the mask is a path string.\n    return mask;\n  }\n}\n\nfunction getCleanMask(resolvedMask) {\n  return resolvedMask instanceof URL ? getCleanUrl_1.getCleanUrl(resolvedMask) : resolvedMask instanceof RegExp ? resolvedMask : getAbsoluteUrl(resolvedMask);\n}\n/**\r\n * Returns the result of matching given request URL\r\n * against a mask.\r\n */\n\n\nfunction matchRequestUrl(url, mask) {\n  const resolvedMask = getUrlByMask(mask);\n  const cleanMask = getCleanMask(resolvedMask);\n  const cleanRequestUrl = getCleanUrl_1.getCleanUrl(url);\n  return match(cleanMask, cleanRequestUrl);\n}\n/**\r\n * Return the stack trace frame of a function's invocation.\r\n */\n\n\nfunction getCallFrame() {\n  try {\n    const inspectionError = new Error();\n    inspectionError.name = 'Inspection Error';\n    throw inspectionError;\n  } catch (error) {\n    const frames = error.stack.split('\\n'); // Get the first frame that doesn't reference the library's internal trace.\n    // Assume that frame is the invocation frame.\n\n    const declarationFrame = frames.slice(1).find(frame => {\n      return !/(node_modules)?\\/lib\\/(umd|esm)\\//.test(frame);\n    });\n\n    if (!declarationFrame) {\n      return;\n    } // Extract file reference from the stack frame.\n\n\n    const [, declarationPath] = declarationFrame.match(/\\((.+?)\\)$/) || [];\n    return declarationPath;\n  }\n}\n\nexport { getCallFrame as a, prepareRequest as b, prepareResponse as c, getTimestamp as d, getStatusCodeColor as e, getUrlByMask as g, matchRequestUrl as m, parseBody as p };","map":{"version":3,"sources":["/Users/haoyan/reactpro/项目/jira项目/fake-jira-main/node_modules/msw/lib/esm/getCallFrame-deps.js"],"names":["e","jsonParse","l","lib","c","createCommonjsModule","parseBody","body","headers","_a","hasJsonContent","get","includes","prepareRequest","req","Object","assign","getAllHeaders","prepareResponse","res","responseHeaders","listToHeaders","getTimestamp","now","Date","getHours","getMinutes","getSeconds","map","String","chunk","slice","padStart","join","getStatusCodeColor","status","pathToRegExp","path","pattern","replace","_","paramName","concat","RegExp","match","url","expression","exec","matches","input","params","groups","getCleanUrl_1","module","exports","defineProperty","value","getCleanUrl","isAbsolute","origin","pathname","filter","Boolean","getAbsoluteUrl","mask","hasLocation","location","startsWith","getUrlByMask","URL","error","getCleanMask","resolvedMask","matchRequestUrl","cleanMask","cleanRequestUrl","getCallFrame","inspectionError","Error","name","frames","stack","split","declarationFrame","find","frame","test","declarationPath","a","b","d","g","m","p"],"mappings":"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","sourcesContent":["import { e as jsonParse, l as lib, c as createCommonjsModule } from './fetch-deps.js';\n\n/**\r\n * Parses a given request/response body based on the `Content-Type` header.\r\n */\r\nfunction parseBody(body, headers) {\r\n    var _a;\r\n    if (body) {\r\n        // If the intercepted request's body has a JSON Content-Type\r\n        // parse it into an object, otherwise leave as-is.\r\n        const hasJsonContent = (_a = headers === null || headers === void 0 ? void 0 : headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('json');\r\n        if (hasJsonContent && typeof body !== 'object') {\r\n            return jsonParse(body) || body;\r\n        }\r\n        return body;\r\n    }\r\n    // Return whatever falsey body value is given.\r\n    return body;\r\n}\n\n/**\r\n * Formats a mocked request for introspection in browser's console.\r\n */\r\nfunction prepareRequest(req) {\r\n    return Object.assign(Object.assign({}, req), { headers: req.headers.getAllHeaders() });\r\n}\n\n/**\r\n * Formats a mocked response for introspection in browser's console.\r\n */\r\nfunction prepareResponse(res) {\r\n    const responseHeaders = lib.listToHeaders(res.headers);\r\n    return Object.assign(Object.assign({}, res), { \r\n        // Parse a response JSON body for preview in the logs\r\n        body: parseBody(res.body, responseHeaders) });\r\n}\n\nfunction getTimestamp() {\r\n    const now = new Date();\r\n    return [now.getHours(), now.getMinutes(), now.getSeconds()]\r\n        .map(String)\r\n        .map((chunk) => chunk.slice(0, 2))\r\n        .map((chunk) => chunk.padStart(2, '0'))\r\n        .join(':');\r\n}\n\n/**\r\n * Returns a HEX color for a given response status code number.\r\n */\r\nfunction getStatusCodeColor(status) {\r\n    if (status < 300) {\r\n        return '#69AB32';\r\n    }\r\n    if (status < 400) {\r\n        return '#F0BB4B';\r\n    }\r\n    return '#E95F5D';\r\n}\n\n/**\r\n * Converts a string path to a Regular Expression.\r\n * Transforms path parameters into named RegExp groups.\r\n */\r\nconst pathToRegExp = (path) => {\r\n    const pattern = path\r\n        // Escape literal dots\r\n        .replace(/\\./g, '\\\\.')\r\n        // Escape literal slashes\r\n        .replace(/\\//g, '/')\r\n        // Escape literal question marks\r\n        .replace(/\\?/g, '\\\\?')\r\n        // Ignore trailing slashes\r\n        .replace(/\\/+$/, '')\r\n        // Replace wildcard with any zero-to-any character sequence\r\n        .replace(/\\*+/g, '.*')\r\n        // Replace parameters with named capturing groups\r\n        .replace(/:([^\\d|^\\/][a-zA-Z0-9_]*(?=(?:\\/|\\\\.)|$))/g, (_, paramName) => `(?<${paramName}>[^\\/]+?)`)\r\n        // Allow optional trailing slash\r\n        .concat('(\\\\/|$)');\r\n    return new RegExp(pattern, 'gi');\r\n};\n\n/**\r\n * Matches a given url against a path.\r\n */\r\nconst match = (path, url) => {\r\n    const expression = path instanceof RegExp ? path : pathToRegExp(path);\r\n    const match = expression.exec(url) || false;\r\n    // Matches in strict mode: match string should equal to input (url)\r\n    // Otherwise loose matches will be considered truthy:\r\n    // match('/messages/:id', '/messages/123/users') // true\r\n    const matches = path instanceof RegExp ? !!match : !!match && match[0] === match.input;\r\n    return {\r\n        matches,\r\n        params: match && matches ? match.groups || null : null,\r\n    };\r\n};\n\nvar getCleanUrl_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCleanUrl = void 0;\n/**\n * Removes query parameters and hashes from a given URL.\n */\nfunction getCleanUrl(url, isAbsolute) {\n    if (isAbsolute === void 0) { isAbsolute = true; }\n    return [isAbsolute && url.origin, url.pathname].filter(Boolean).join('');\n}\nexports.getCleanUrl = getCleanUrl;\n\n});\n\n/**\r\n * Returns an absolute URL based on the given relative URL, if possible.\r\n * Ignores regular expressions.\r\n */\r\nconst getAbsoluteUrl = (mask) => {\r\n    // Global `location` object doesn't exist in Node.\r\n    // Relative request predicate URL cannot become absolute.\r\n    const hasLocation = typeof location !== 'undefined';\r\n    return typeof mask === 'string' && mask.startsWith('/')\r\n        ? `${hasLocation ? location.origin : ''}${mask}`\r\n        : mask;\r\n};\n\n/**\r\n * Converts a given request handler mask into a URL, if given a valid URL string.\r\n */\r\nfunction getUrlByMask(mask) {\r\n    /**\r\n     * If a string mask contains an asterisk (wildcard), return it as-is.\r\n     * Converting a URL-like path string into an actual URL is misleading.\r\n     * @see https://github.com/mswjs/msw/issues/357\r\n     */\r\n    if (mask instanceof RegExp || mask.includes('*')) {\r\n        return mask;\r\n    }\r\n    try {\r\n        // Attempt to create a URL instance out of the mask string.\r\n        // Resolve mask to an absolute URL, because even a valid relative URL\r\n        // cannot be converted into the URL instance (required absolute URL only).\r\n        return new URL(getAbsoluteUrl(mask));\r\n    }\r\n    catch (error) {\r\n        // Otherwise, the mask is a path string.\r\n        return mask;\r\n    }\r\n}\n\nfunction getCleanMask(resolvedMask) {\r\n    return resolvedMask instanceof URL\r\n        ? getCleanUrl_1.getCleanUrl(resolvedMask)\r\n        : resolvedMask instanceof RegExp\r\n            ? resolvedMask\r\n            : getAbsoluteUrl(resolvedMask);\r\n}\n\n/**\r\n * Returns the result of matching given request URL\r\n * against a mask.\r\n */\r\nfunction matchRequestUrl(url, mask) {\r\n    const resolvedMask = getUrlByMask(mask);\r\n    const cleanMask = getCleanMask(resolvedMask);\r\n    const cleanRequestUrl = getCleanUrl_1.getCleanUrl(url);\r\n    return match(cleanMask, cleanRequestUrl);\r\n}\n\n/**\r\n * Return the stack trace frame of a function's invocation.\r\n */\r\nfunction getCallFrame() {\r\n    try {\r\n        const inspectionError = new Error();\r\n        inspectionError.name = 'Inspection Error';\r\n        throw inspectionError;\r\n    }\r\n    catch (error) {\r\n        const frames = error.stack.split('\\n');\r\n        // Get the first frame that doesn't reference the library's internal trace.\r\n        // Assume that frame is the invocation frame.\r\n        const declarationFrame = frames.slice(1).find((frame) => {\r\n            return !/(node_modules)?\\/lib\\/(umd|esm)\\//.test(frame);\r\n        });\r\n        if (!declarationFrame) {\r\n            return;\r\n        }\r\n        // Extract file reference from the stack frame.\r\n        const [, declarationPath] = declarationFrame.match(/\\((.+?)\\)$/) || [];\r\n        return declarationPath;\r\n    }\r\n}\n\nexport { getCallFrame as a, prepareRequest as b, prepareResponse as c, getTimestamp as d, getStatusCodeColor as e, getUrlByMask as g, matchRequestUrl as m, parseBody as p };\n"]},"metadata":{},"sourceType":"module"}