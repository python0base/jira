{"ast":null,"code":"import { c as createCommonjsModule, s as status, a as set, d as delay, f as fetch, l as lib$1, i as isNodeProcess } from './fetch-deps.js';\nimport { p as parse_1 } from './xml-deps.js';\nimport { m as mergeRight } from './errors-deps.js';\nexport { i as context } from './index-deps.js';\nimport { g as getPublicUrlFromRequest, i as isStringEqual } from './rest-deps.js';\nexport { R as RESTMethods, r as rest, a as restContext } from './rest-deps.js';\nimport { p as parseBody } from './getCallFrame-deps.js';\nexport { m as matchRequestUrl } from './getCallFrame-deps.js';\nexport { graphql, graphqlContext } from './graphql.js';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nvar until = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  /**\n   * Gracefully handles a given Promise factory.\n   * @example\n   * cosnt [error, data] = await until(() => asyncAction())\n   */\n\n  exports.until = async promise => {\n    try {\n      const data = await promise().catch(error => {\n        throw error;\n      });\n      return [null, data];\n    } catch (error) {\n      return [error, null];\n    }\n  };\n});\nvar lib = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.until = until.until;\n});\n/**\r\n * Attempts to resolve a Service Worker instance from a given registration,\r\n * regardless of its state (active, installing, waiting).\r\n */\n\nconst getWorkerByRegistration = (registration, absoluteWorkerUrl, findWorker) => {\n  const allStates = [registration.active, registration.installing, registration.waiting];\n  const existingStates = allStates.filter(Boolean);\n  const mockWorker = existingStates.find(worker => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl);\n  });\n  return mockWorker || null;\n};\n/**\r\n * Returns an absolute Service Worker URL based on the given\r\n * relative URL (known during the registration).\r\n */\n\n\nfunction getAbsoluteWorkerUrl(relativeUrl) {\n  return new URL(relativeUrl, location.origin).href;\n}\n/**\r\n * Returns an active Service Worker instance.\r\n * When not found, registers a new Service Worker.\r\n */\n\n\nconst getWorkerInstance = (url, options = {}, findWorker) => __awaiter(void 0, void 0, void 0, function* () {\n  // Resolve the absolute Service Worker URL.\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n  const [, mockRegistrations] = yield lib.until(() => __awaiter(void 0, void 0, void 0, function* () {\n    const registrations = yield navigator.serviceWorker.getRegistrations();\n    return registrations.filter(registration => {\n      return getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker);\n    });\n  }));\n\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    // Reload the page when it has associated workers, but no active controller.\n    // The absence of a controller can mean either:\n    // - page has no Service Worker associated with it\n    // - page has been hard-reloaded and its workers won't be used until the next reload.\n    // Since we've checked that there are registrations associated with this page,\n    // at this point we are sure it's hard reload that falls into this clause.\n    location.reload();\n  }\n\n  const [existingRegistration] = mockRegistrations;\n\n  if (existingRegistration) {\n    // When the Service Worker is registered, update it and return the reference.\n    return existingRegistration.update().then(() => {\n      return [getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker), existingRegistration];\n    });\n  } // When the Service Worker wasn't found, register it anew and return the reference.\n\n\n  const [error, instance] = yield lib.until(() => __awaiter(void 0, void 0, void 0, function* () {\n    const registration = yield navigator.serviceWorker.register(url, options);\n    return [// Compare existing worker registration by its worker URL,\n    // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n    getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker), registration];\n  })); // Handle Service Worker registration errors.\n\n  if (error) {\n    const isWorkerMissing = error.message.includes('(404)'); // Produce a custom error message when given a non-existing Service Worker url.\n    // Suggest developers to check their setup.\n\n    if (isWorkerMissing) {\n      const scopeUrl = new URL((options === null || options === void 0 ? void 0 : options.scope) || '/', location.href);\n      console.error(`\\\n[MSW] Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`);\n      return null;\n    } // Fallback error message for any other registration errors.\n\n\n    console.error(`[MSW] Failed to register a Service Worker:\\n\\n${error.message}`);\n    return null;\n  }\n\n  return instance;\n});\n\nconst activateMocking = (context, options) => __awaiter(void 0, void 0, void 0, function* () {\n  var _a;\n\n  (_a = context.worker) === null || _a === void 0 ? void 0 : _a.postMessage('MOCK_ACTIVATE');\n  return context.events.once('MOCKING_ENABLED').then(() => {\n    if (!(options === null || options === void 0 ? void 0 : options.quiet)) {\n      console.groupCollapsed('%c[MSW] Mocking enabled.', 'color:orangered;font-weight:bold;');\n      console.log('%cDocumentation: %chttps://mswjs.io/docs', 'font-weight:bold', 'font-weight:normal');\n      console.log('Found an issue? https://github.com/mswjs/msw/issues');\n      console.groupEnd();\n    }\n  });\n});\n/**\r\n * Creates a communication channel between the client\r\n * and the Service Worker associated with the given event.\r\n */\n\n\nconst createBroadcastChannel = event => {\n  const port = event.ports[0];\n  return {\n    /**\r\n     * Sends a text message to the connected Service Worker.\r\n     */\n    send(message) {\n      if (port) {\n        port.postMessage(message);\n      }\n    }\n\n  };\n};\n\nconst defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\n/**\r\n * Composes a given list of functions into a new function that\r\n * executes from right to left.\r\n */\n\nfunction compose(...fns) {\n  return (...args) => {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, args[0]);\n  };\n}\n\nclass NetworkError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'NetworkError';\n  }\n\n}\n\nconst defaultResponse = {\n  status: 200,\n  statusText: 'OK',\n  body: null,\n  delay: 0,\n  once: false\n};\nconst defaultResponseTransformers = [];\n\nfunction createResponseComposition(responseOverrides, defaultTransformers = defaultResponseTransformers) {\n  return (...transformers) => __awaiter(this, void 0, void 0, function* () {\n    const initialResponse = Object.assign({}, defaultResponse, {\n      headers: new lib$1.Headers({\n        'x-powered-by': 'msw'\n      })\n    }, responseOverrides);\n    const resolvedTransformers = [...defaultTransformers, ...transformers].filter(Boolean);\n    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n    return resolvedResponse;\n  });\n}\n\nconst response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({\n    once: true\n  }),\n\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n\n});\n/**\r\n * Returns a mocked response for a given request using following request handlers.\r\n */\n\nconst getResponse = (req, handlers) => __awaiter(void 0, void 0, void 0, function* () {\n  const relevantHandlers = handlers.filter(requestHandler => {\n    // Skip a handler if it has been already used for a one-time response.\n    return !requestHandler.shouldSkip;\n  }).map(requestHandler => {\n    // Parse the captured request to get additional information.\n    // Make the predicate function accept all the necessary information\n    // to decide on the interception.\n    const parsedRequest = requestHandler.parse ? requestHandler.parse(req) : null;\n    return [requestHandler, parsedRequest];\n  }).filter(([requestHandler, parsedRequest]) => {\n    return requestHandler.predicate(req, parsedRequest);\n  });\n\n  if (relevantHandlers.length == 0) {\n    // Handle a scenario when a request has no relevant request handlers.\n    // In that case it would be bypassed (performed as-is).\n    return {\n      handler: null,\n      response: null\n    };\n  }\n\n  const {\n    requestHandler,\n    parsedRequest,\n    mockedResponse,\n    publicRequest\n  } = yield relevantHandlers.reduce((asyncAcc, [requestHandler, parsedRequest]) => __awaiter(void 0, void 0, void 0, function* () {\n    // Now the reduce function is async so we need to await if response was found\n    const acc = yield asyncAcc; // If a first not empty response was found we'll stop evaluating other requests\n\n    if (acc.requestHandler) {\n      return acc;\n    }\n\n    const {\n      getPublicRequest,\n      defineContext,\n      resolver\n    } = requestHandler;\n    const publicRequest = getPublicRequest ? getPublicRequest(req, parsedRequest) : req;\n    const context = defineContext ? defineContext(publicRequest) : defaultContext;\n    const mockedResponse = yield resolver(publicRequest, response, context);\n\n    if (!mockedResponse) {\n      return acc;\n    }\n\n    if (mockedResponse && mockedResponse.once) {\n      // When responded with a one-time response, match the relevant request handler\n      // as skipped, so it cannot affect the captured requests anymore.\n      requestHandler.shouldSkip = true;\n    }\n\n    return {\n      requestHandler,\n      parsedRequest,\n      mockedResponse,\n      publicRequest\n    };\n  }), Promise.resolve({\n    mockedResponse: null\n  })); // Although reducing a list of relevant request handlers, it's possible\n  // that in the end there will be no handler associted with the request\n  // (i.e. if relevant handlers are fall-through).\n\n  if (!requestHandler) {\n    return {\n      handler: null,\n      response: null\n    };\n  }\n\n  return {\n    handler: requestHandler,\n    response: mockedResponse,\n    publicRequest,\n    parsedRequest\n  };\n});\n\nfunction onUnhandledRequest(request, handler = 'bypass') {\n  if (typeof handler === 'function') {\n    handler(request);\n    return;\n  }\n\n  const publicUrl = getPublicUrlFromRequest(request);\n  const message = `captured a ${request.method} ${request.url} request without a corresponding request handler.\n\n  If you wish to intercept this request, consider creating a request handler for it:\n\n  rest.${request.method.toLowerCase()}('${publicUrl}', (req, res, ctx) => {\n    return res(ctx.text('body'))\n  })`;\n\n  switch (handler) {\n    case 'error':\n      {\n        throw new Error(`[MSW] Error: ${message}`);\n      }\n\n    case 'warn':\n      {\n        console.warn(`[MSW] Warning: ${message}`);\n      }\n\n    default:\n      return;\n  }\n}\n\nfunction getAllCookies() {\n  return parse_1(document.cookie);\n}\n/**\r\n * Returns relevant document cookies based on the request `credentials` option.\r\n */\n\n\nfunction getRequestCookies(req) {\n  switch (req.credentials) {\n    case 'same-origin':\n      {\n        // Return document cookies only when requested a resource\n        // from the same origin as the current document.\n        return location.origin === req.url.origin ? getAllCookies() : {};\n      }\n\n    case 'include':\n      {\n        // Return all document cookies.\n        return getAllCookies();\n      }\n\n    default:\n      {\n        return {};\n      }\n  }\n}\n\nconst handleRequestWith = (context, options) => {\n  return event => __awaiter(void 0, void 0, void 0, function* () {\n    const channel = createBroadcastChannel(event);\n\n    try {\n      const message = JSON.parse(event.data, function (key, value) {\n        if (key === 'url') {\n          return new URL(value);\n        } // Serialize headers\n\n\n        if (key === 'headers') {\n          return new lib$1.Headers(value);\n        } // Prevent empty fields from presering an empty value.\n        // It's invalid to perform a GET request with { body: \"\" }\n\n\n        if ( // Check if we are parsing deeper in `event.data.payload`,\n        // because this custom JSON parser is invoked for each depth level.\n        this.method && isStringEqual(this.method, 'GET') && key === 'body' && value === '') {\n          return undefined;\n        }\n\n        return value;\n      });\n      const {\n        type,\n        payload: req\n      } = message; // Ignore irrelevant worker message types\n\n      if (type !== 'REQUEST') {\n        return null;\n      } // Parse the request's body based on the \"Content-Type\" header.\n\n\n      req.body = parseBody(req.body, req.headers); // Set document cookies on the request.\n\n      req.cookies = getRequestCookies(req);\n      const {\n        response,\n        handler,\n        publicRequest,\n        parsedRequest\n      } = yield getResponse(req, context.requestHandlers); // Handle a scenario when there is no request handler\n      // found for a given request.\n\n      if (!handler) {\n        onUnhandledRequest(req, options.onUnhandledRequest);\n        return channel.send({\n          type: 'MOCK_NOT_FOUND'\n        });\n      } // Handle a scenario when there is a request handler,\n      // but it doesn't return any mocked response.\n\n\n      if (!response) {\n        console.warn('[MSW] Expected a mocking resolver function to return a mocked response Object, but got: %s. Original response is going to be used instead.', response);\n        return channel.send({\n          type: 'MOCK_NOT_FOUND'\n        });\n      }\n\n      const responseWithSerializedHeaders = Object.assign(Object.assign({}, response), {\n        headers: lib$1.headersToList(response.headers)\n      });\n\n      if (!options.quiet) {\n        setTimeout(() => {\n          handler.log(publicRequest, responseWithSerializedHeaders, handler, parsedRequest);\n        }, response.delay);\n      }\n\n      channel.send({\n        type: 'MOCK_SUCCESS',\n        payload: responseWithSerializedHeaders\n      });\n    } catch (error) {\n      if (error instanceof NetworkError) {\n        // Treat emulated network error differently,\n        // as it is an intended exception in a request handler.\n        return channel.send({\n          type: 'NETWORK_ERROR',\n          payload: {\n            name: error.name,\n            message: error.message\n          }\n        });\n      } // Treat all the other exceptions in a request handler\n      // as unintended, alerting that there is a problem needs fixing.\n\n\n      channel.send({\n        type: 'INTERNAL_ERROR',\n        payload: {\n          status: 500,\n          body: JSON.stringify({\n            errorType: error.constructor.name,\n            message: error.message,\n            location: error.stack\n          })\n        }\n      });\n    }\n  });\n};\n\nfunction requestIntegrityCheck(context, serviceWorker) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // Signal Service Worker to report back its integrity\n    serviceWorker.postMessage('INTEGRITY_CHECK_REQUEST');\n    const {\n      payload: actualChecksum\n    } = yield context.events.once('INTEGRITY_CHECK_RESPONSE'); // Compare the response from the Service Worker and the\n    // global variable set by webpack upon build.\n\n    if (actualChecksum !== \"65d33ca82955e1c5928aed19d1bdf3f9\") {\n      throw new Error(`Currently active Service Worker (${actualChecksum}) is behind the latest published one (${\"65d33ca82955e1c5928aed19d1bdf3f9\"}).`);\n    }\n\n    return serviceWorker;\n  });\n}\n/**\r\n * Intercepts and defers any requests on the page\r\n * until the Service Worker instance is ready.\r\n * Must only be used in a browser.\r\n */\n\n\nfunction deferNetworkRequestsUntil(predicatePromise) {\n  // Defer any `XMLHttpRequest` requests until the Service Worker is ready.\n  const originalXhrSend = window.XMLHttpRequest.prototype.send;\n\n  window.XMLHttpRequest.prototype.send = function (...args) {\n    // Keep this function synchronous to comply with `XMLHttpRequest.prototype.send`,\n    // because that method is always synchronous.\n    lib.until(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend;\n      this.send(...args);\n    });\n  }; // Defer any `fetch` requests until the Service Worker is ready.\n\n\n  const originalFetch = window.fetch;\n\n  window.fetch = (...args) => __awaiter(this, void 0, void 0, function* () {\n    yield lib.until(() => predicatePromise);\n    window.fetch = originalFetch;\n    return window.fetch(...args);\n  });\n}\n\nconst DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'bypass',\n  findWorker: (scriptURL, mockServiceWorkerUrl) => scriptURL === mockServiceWorkerUrl\n};\n\nconst createStart = context => {\n  /**\r\n   * Registers and activates the mock Service Worker.\r\n   */\n  return function start(options) {\n    const resolvedOptions = mergeRight(DEFAULT_START_OPTIONS, options || {});\n\n    const startWorkerInstance = () => __awaiter(this, void 0, void 0, function* () {\n      if (!('serviceWorker' in navigator)) {\n        console.error(`[MSW] Failed to register a Service Worker: this browser does not support Service Workers (see https://caniuse.com/serviceworkers), or your application is running on an insecure host (consider using HTTPS for custom hostnames).`);\n        return null;\n      } // Remove all previously existing event listeners.\n      // This way none of the listeners persists between Fast refresh\n      // of the application's code.\n\n\n      context.events.removeAllListeners();\n      context.events.addListener(navigator.serviceWorker, 'message', handleRequestWith(context, resolvedOptions));\n      const [, instance] = yield lib.until(() => getWorkerInstance(resolvedOptions.serviceWorker.url, resolvedOptions.serviceWorker.options, resolvedOptions.findWorker));\n\n      if (!instance) {\n        return null;\n      }\n\n      const [worker, registration] = instance;\n\n      if (!worker) {\n        if (options === null || options === void 0 ? void 0 : options.findWorker) {\n          console.error(`\\\n[MSW] Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"${resolvedOptions.serviceWorker.url}\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`);\n        } else {\n          console.error(`\\\n[MSW] Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"${resolvedOptions.serviceWorker.url}\" cannot resolve against the actual public hostname (${location.host}). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`);\n        }\n\n        return null;\n      }\n\n      context.worker = worker;\n      context.registration = registration;\n      context.events.addListener(window, 'beforeunload', () => {\n        if (worker.state !== 'redundant') {\n          // Notify the Service Worker that this client has closed.\n          // Internally, it's similar to disabling the mocking, only\n          // client close event has a handler that self-terminates\n          // the Service Worker when there are no open clients.\n          worker.postMessage('CLIENT_CLOSED');\n        } // Make sure we're always clearing the interval - there are reports that not doing this can\n        // cause memory leaks in headless browser environments.\n\n\n        window.clearInterval(context.keepAliveInterval);\n      }); // Check if the active Service Worker is the latest published one\n\n      const [integrityError] = yield lib.until(() => requestIntegrityCheck(context, worker));\n\n      if (integrityError) {\n        console.error(`\\\n[MSW] Detected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues\\\n      `);\n      } // Signal the Service Worker to enable requests interception\n\n\n      const [activationError] = yield lib.until(() => activateMocking(context, options));\n\n      if (activationError) {\n        console.error('Failed to enable mocking', activationError);\n        return null;\n      }\n\n      context.keepAliveInterval = window.setInterval(() => worker.postMessage('KEEPALIVE_REQUEST'), 5000);\n      return registration;\n    });\n\n    const workerRegistration = startWorkerInstance(); // Defer any network requests until the Service Worker instance is ready.\n    // This prevents a race condition between the Service Worker registration\n    // and application's runtime requests (i.e. requests on mount).\n\n    if (resolvedOptions.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration);\n    }\n\n    return workerRegistration;\n  };\n};\n\nconst createStop = context => {\n  /**\r\n   * Signal the Service Worker to disable mocking for this client.\r\n   * Use this an an explicit way to stop the mocking, while preserving\r\n   * the worker-client relation. Does not affect the worker's lifecycle.\r\n   */\n  return function stop() {\n    var _a;\n\n    (_a = context.worker) === null || _a === void 0 ? void 0 : _a.postMessage('MOCK_DEACTIVATE');\n    context.events.removeAllListeners();\n    window.clearInterval(context.keepAliveInterval);\n  };\n};\n\nfunction use(currentHandlers, ...handlers) {\n  currentHandlers.unshift(...handlers);\n}\n\nfunction restoreHandlers(handlers) {\n  handlers.forEach(handler => {\n    if ('shouldSkip' in handler) {\n      handler.shouldSkip = false;\n    }\n  });\n}\n\nfunction resetHandlers(initialHandlers, ...nextHandlers) {\n  return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers];\n} // Declare the list of event handlers on the module's scope\n// so it persists between Fash refreshes of the application's code.\n\n\nlet listeners = [];\n/**\r\n * Creates a new mock Service Worker registration\r\n * with the given request handlers.\r\n * @param {RequestHandler[]} requestHandlers List of request handlers\r\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker`}\r\n */\n\nfunction setupWorker(...requestHandlers) {\n  requestHandlers.forEach(handler => {\n    if (Array.isArray(handler)) throw new Error(`[MSW] Failed to call \"setupWorker\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).`);\n  });\n  const context = {\n    worker: null,\n    registration: null,\n    requestHandlers: [...requestHandlers],\n    events: {\n      addListener(target, event, callback) {\n        target.addEventListener(event, callback);\n        listeners.push({\n          event,\n          target,\n          callback\n        });\n        return () => {\n          target.removeEventListener(event, callback);\n        };\n      },\n\n      removeAllListeners() {\n        for (const {\n          target,\n          event,\n          callback\n        } of listeners) {\n          target.removeEventListener(event, callback);\n        }\n\n        listeners = [];\n      },\n\n      once(type) {\n        const bindings = [];\n        return new Promise((resolve, reject) => {\n          const handleIncomingMessage = event => {\n            try {\n              const message = JSON.parse(event.data);\n\n              if (message.type === type) {\n                resolve(message);\n              }\n            } catch (error) {\n              reject(error);\n            }\n          };\n\n          bindings.push(context.events.addListener(navigator.serviceWorker, 'message', handleIncomingMessage), context.events.addListener(navigator.serviceWorker, 'messageerror', reject));\n        }).finally(() => {\n          bindings.forEach(unbind => unbind());\n        });\n      }\n\n    }\n  }; // Error when attempting to run this function in a NodeJS environment.\n\n  if (isNodeProcess()) {\n    throw new Error('[MSW] Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for NodeJS environment instead.');\n  }\n\n  return {\n    start: createStart(context),\n    stop: createStop(context),\n\n    use(...handlers) {\n      use(context.requestHandlers, ...handlers);\n    },\n\n    restoreHandlers() {\n      restoreHandlers(context.requestHandlers);\n    },\n\n    resetHandlers(...nextHandlers) {\n      context.requestHandlers = resetHandlers(requestHandlers, ...nextHandlers);\n    },\n\n    printHandlers() {\n      context.requestHandlers.forEach(handler => {\n        const meta = handler.getMetaInfo();\n        console.groupCollapsed(meta.header);\n        console.log(`Declaration: ${meta.callFrame}`);\n        console.log('Resolver: %s', handler.resolver);\n\n        if (['rest'].includes(meta.type)) {\n          console.log('Match:', `https://mswjs.io/repl?path=${meta.mask}`);\n        }\n\n        console.groupEnd();\n      });\n    }\n\n  };\n}\n\nexport { compose, createResponseComposition, defaultContext, defaultResponse, response, setupWorker };","map":{"version":3,"sources":["/Users/haoyan/reactpro/项目/jira项目/fake-jira-main/node_modules/msw/lib/esm/index.js"],"names":["c","createCommonjsModule","s","status","a","set","d","delay","f","fetch","l","lib$1","i","isNodeProcess","p","parse_1","m","mergeRight","context","g","getPublicUrlFromRequest","isStringEqual","R","RESTMethods","r","rest","restContext","parseBody","matchRequestUrl","graphql","graphqlContext","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","until","module","exports","Object","defineProperty","promise","data","catch","error","lib","getWorkerByRegistration","registration","absoluteWorkerUrl","findWorker","allStates","active","installing","waiting","existingStates","filter","Boolean","mockWorker","find","worker","scriptURL","getAbsoluteWorkerUrl","relativeUrl","URL","location","origin","href","getWorkerInstance","url","options","mockRegistrations","registrations","navigator","serviceWorker","getRegistrations","controller","length","reload","existingRegistration","update","instance","register","isWorkerMissing","message","includes","scopeUrl","scope","console","activateMocking","_a","postMessage","events","once","quiet","groupCollapsed","log","groupEnd","createBroadcastChannel","event","port","ports","send","defaultContext","compose","fns","args","reduceRight","leftFn","rightFn","NetworkError","Error","constructor","name","defaultResponse","statusText","body","defaultResponseTransformers","createResponseComposition","responseOverrides","defaultTransformers","transformers","initialResponse","assign","headers","Headers","resolvedTransformers","resolvedResponse","response","networkError","getResponse","req","handlers","relevantHandlers","requestHandler","shouldSkip","map","parsedRequest","parse","predicate","handler","mockedResponse","publicRequest","reduce","asyncAcc","acc","getPublicRequest","defineContext","resolver","onUnhandledRequest","request","publicUrl","method","toLowerCase","warn","getAllCookies","document","cookie","getRequestCookies","credentials","handleRequestWith","channel","JSON","key","undefined","type","payload","cookies","requestHandlers","responseWithSerializedHeaders","headersToList","setTimeout","stringify","errorType","stack","requestIntegrityCheck","actualChecksum","deferNetworkRequestsUntil","predicatePromise","originalXhrSend","window","XMLHttpRequest","prototype","originalFetch","DEFAULT_START_OPTIONS","waitUntilReady","mockServiceWorkerUrl","createStart","start","resolvedOptions","startWorkerInstance","removeAllListeners","addListener","host","state","clearInterval","keepAliveInterval","integrityError","activationError","setInterval","workerRegistration","createStop","stop","use","currentHandlers","unshift","restoreHandlers","forEach","resetHandlers","initialHandlers","nextHandlers","listeners","setupWorker","Array","isArray","target","callback","addEventListener","push","removeEventListener","bindings","handleIncomingMessage","finally","unbind","printHandlers","meta","getMetaInfo","header","callFrame","mask"],"mappings":"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","sourcesContent":["import { c as createCommonjsModule, s as status, a as set, d as delay, f as fetch, l as lib$1, i as isNodeProcess } from './fetch-deps.js';\nimport { p as parse_1 } from './xml-deps.js';\nimport { m as mergeRight } from './errors-deps.js';\nexport { i as context } from './index-deps.js';\nimport { g as getPublicUrlFromRequest, i as isStringEqual } from './rest-deps.js';\nexport { R as RESTMethods, r as rest, a as restContext } from './rest-deps.js';\nimport { p as parseBody } from './getCallFrame-deps.js';\nexport { m as matchRequestUrl } from './getCallFrame-deps.js';\nexport { graphql, graphqlContext } from './graphql.js';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nvar until = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Gracefully handles a given Promise factory.\n * @example\n * cosnt [error, data] = await until(() => asyncAction())\n */\nexports.until = async (promise) => {\n    try {\n        const data = await promise().catch((error) => {\n            throw error;\n        });\n        return [null, data];\n    }\n    catch (error) {\n        return [error, null];\n    }\n};\n});\n\nvar lib = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nexports.until = until.until;\n});\n\n/**\r\n * Attempts to resolve a Service Worker instance from a given registration,\r\n * regardless of its state (active, installing, waiting).\r\n */\r\nconst getWorkerByRegistration = (registration, absoluteWorkerUrl, findWorker) => {\r\n    const allStates = [\r\n        registration.active,\r\n        registration.installing,\r\n        registration.waiting,\r\n    ];\r\n    const existingStates = allStates.filter(Boolean);\r\n    const mockWorker = existingStates.find((worker) => {\r\n        return findWorker(worker.scriptURL, absoluteWorkerUrl);\r\n    });\r\n    return mockWorker || null;\r\n};\n\n/**\r\n * Returns an absolute Service Worker URL based on the given\r\n * relative URL (known during the registration).\r\n */\r\nfunction getAbsoluteWorkerUrl(relativeUrl) {\r\n    return new URL(relativeUrl, location.origin).href;\r\n}\n\n/**\r\n * Returns an active Service Worker instance.\r\n * When not found, registers a new Service Worker.\r\n */\r\nconst getWorkerInstance = (url, options = {}, findWorker) => __awaiter(void 0, void 0, void 0, function* () {\r\n    // Resolve the absolute Service Worker URL.\r\n    const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\r\n    const [, mockRegistrations] = yield lib.until(() => __awaiter(void 0, void 0, void 0, function* () {\r\n        const registrations = yield navigator.serviceWorker.getRegistrations();\r\n        return registrations.filter((registration) => {\r\n            return getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker);\r\n        });\r\n    }));\r\n    if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\r\n        // Reload the page when it has associated workers, but no active controller.\r\n        // The absence of a controller can mean either:\r\n        // - page has no Service Worker associated with it\r\n        // - page has been hard-reloaded and its workers won't be used until the next reload.\r\n        // Since we've checked that there are registrations associated with this page,\r\n        // at this point we are sure it's hard reload that falls into this clause.\r\n        location.reload();\r\n    }\r\n    const [existingRegistration] = mockRegistrations;\r\n    if (existingRegistration) {\r\n        // When the Service Worker is registered, update it and return the reference.\r\n        return existingRegistration.update().then(() => {\r\n            return [\r\n                getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker),\r\n                existingRegistration,\r\n            ];\r\n        });\r\n    }\r\n    // When the Service Worker wasn't found, register it anew and return the reference.\r\n    const [error, instance] = yield lib.until(() => __awaiter(void 0, void 0, void 0, function* () {\r\n        const registration = yield navigator.serviceWorker.register(url, options);\r\n        return [\r\n            // Compare existing worker registration by its worker URL,\r\n            // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\r\n            getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\r\n            registration,\r\n        ];\r\n    }));\r\n    // Handle Service Worker registration errors.\r\n    if (error) {\r\n        const isWorkerMissing = error.message.includes('(404)');\r\n        // Produce a custom error message when given a non-existing Service Worker url.\r\n        // Suggest developers to check their setup.\r\n        if (isWorkerMissing) {\r\n            const scopeUrl = new URL((options === null || options === void 0 ? void 0 : options.scope) || '/', location.href);\r\n            console.error(`\\\n[MSW] Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`);\r\n            return null;\r\n        }\r\n        // Fallback error message for any other registration errors.\r\n        console.error(`[MSW] Failed to register a Service Worker:\\n\\n${error.message}`);\r\n        return null;\r\n    }\r\n    return instance;\r\n});\n\nconst activateMocking = (context, options) => __awaiter(void 0, void 0, void 0, function* () {\r\n    var _a;\r\n    (_a = context.worker) === null || _a === void 0 ? void 0 : _a.postMessage('MOCK_ACTIVATE');\r\n    return context.events.once('MOCKING_ENABLED').then(() => {\r\n        if (!(options === null || options === void 0 ? void 0 : options.quiet)) {\r\n            console.groupCollapsed('%c[MSW] Mocking enabled.', 'color:orangered;font-weight:bold;');\r\n            console.log('%cDocumentation: %chttps://mswjs.io/docs', 'font-weight:bold', 'font-weight:normal');\r\n            console.log('Found an issue? https://github.com/mswjs/msw/issues');\r\n            console.groupEnd();\r\n        }\r\n    });\r\n});\n\n/**\r\n * Creates a communication channel between the client\r\n * and the Service Worker associated with the given event.\r\n */\r\nconst createBroadcastChannel = (event) => {\r\n    const port = event.ports[0];\r\n    return {\r\n        /**\r\n         * Sends a text message to the connected Service Worker.\r\n         */\r\n        send(message) {\r\n            if (port) {\r\n                port.postMessage(message);\r\n            }\r\n        },\r\n    };\r\n};\n\nconst defaultContext = {\r\n    status,\r\n    set,\r\n    delay,\r\n    fetch,\r\n};\n\n/**\r\n * Composes a given list of functions into a new function that\r\n * executes from right to left.\r\n */\r\nfunction compose(...fns) {\r\n    return (...args) => {\r\n        return fns.reduceRight((leftFn, rightFn) => {\r\n            return leftFn instanceof Promise\r\n                ? Promise.resolve(leftFn).then(rightFn)\r\n                : rightFn(leftFn);\r\n        }, args[0]);\r\n    };\r\n}\n\nclass NetworkError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = 'NetworkError';\r\n    }\r\n}\n\nconst defaultResponse = {\r\n    status: 200,\r\n    statusText: 'OK',\r\n    body: null,\r\n    delay: 0,\r\n    once: false,\r\n};\r\nconst defaultResponseTransformers = [];\r\nfunction createResponseComposition(responseOverrides, defaultTransformers = defaultResponseTransformers) {\r\n    return (...transformers) => __awaiter(this, void 0, void 0, function* () {\r\n        const initialResponse = Object.assign({}, defaultResponse, {\r\n            headers: new lib$1.Headers({\r\n                'x-powered-by': 'msw',\r\n            }),\r\n        }, responseOverrides);\r\n        const resolvedTransformers = [\r\n            ...defaultTransformers,\r\n            ...transformers,\r\n        ].filter(Boolean);\r\n        const resolvedResponse = resolvedTransformers.length > 0\r\n            ? compose(...resolvedTransformers)(initialResponse)\r\n            : initialResponse;\r\n        return resolvedResponse;\r\n    });\r\n}\r\nconst response = Object.assign(createResponseComposition(), {\r\n    once: createResponseComposition({ once: true }),\r\n    networkError(message) {\r\n        throw new NetworkError(message);\r\n    },\r\n});\n\n/**\r\n * Returns a mocked response for a given request using following request handlers.\r\n */\r\nconst getResponse = (req, handlers) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const relevantHandlers = handlers\r\n        .filter((requestHandler) => {\r\n        // Skip a handler if it has been already used for a one-time response.\r\n        return !requestHandler.shouldSkip;\r\n    })\r\n        .map((requestHandler) => {\r\n        // Parse the captured request to get additional information.\r\n        // Make the predicate function accept all the necessary information\r\n        // to decide on the interception.\r\n        const parsedRequest = requestHandler.parse\r\n            ? requestHandler.parse(req)\r\n            : null;\r\n        return [requestHandler, parsedRequest];\r\n    })\r\n        .filter(([requestHandler, parsedRequest]) => {\r\n        return requestHandler.predicate(req, parsedRequest);\r\n    });\r\n    if (relevantHandlers.length == 0) {\r\n        // Handle a scenario when a request has no relevant request handlers.\r\n        // In that case it would be bypassed (performed as-is).\r\n        return {\r\n            handler: null,\r\n            response: null,\r\n        };\r\n    }\r\n    const { requestHandler, parsedRequest, mockedResponse, publicRequest, } = yield relevantHandlers.reduce((asyncAcc, [requestHandler, parsedRequest]) => __awaiter(void 0, void 0, void 0, function* () {\r\n        // Now the reduce function is async so we need to await if response was found\r\n        const acc = yield asyncAcc;\r\n        // If a first not empty response was found we'll stop evaluating other requests\r\n        if (acc.requestHandler) {\r\n            return acc;\r\n        }\r\n        const { getPublicRequest, defineContext, resolver } = requestHandler;\r\n        const publicRequest = getPublicRequest\r\n            ? getPublicRequest(req, parsedRequest)\r\n            : req;\r\n        const context = defineContext\r\n            ? defineContext(publicRequest)\r\n            : defaultContext;\r\n        const mockedResponse = yield resolver(publicRequest, response, context);\r\n        if (!mockedResponse) {\r\n            return acc;\r\n        }\r\n        if (mockedResponse && mockedResponse.once) {\r\n            // When responded with a one-time response, match the relevant request handler\r\n            // as skipped, so it cannot affect the captured requests anymore.\r\n            requestHandler.shouldSkip = true;\r\n        }\r\n        return {\r\n            requestHandler,\r\n            parsedRequest,\r\n            mockedResponse,\r\n            publicRequest,\r\n        };\r\n    }), Promise.resolve({ mockedResponse: null }));\r\n    // Although reducing a list of relevant request handlers, it's possible\r\n    // that in the end there will be no handler associted with the request\r\n    // (i.e. if relevant handlers are fall-through).\r\n    if (!requestHandler) {\r\n        return {\r\n            handler: null,\r\n            response: null,\r\n        };\r\n    }\r\n    return {\r\n        handler: requestHandler,\r\n        response: mockedResponse,\r\n        publicRequest,\r\n        parsedRequest,\r\n    };\r\n});\n\nfunction onUnhandledRequest(request, handler = 'bypass') {\r\n    if (typeof handler === 'function') {\r\n        handler(request);\r\n        return;\r\n    }\r\n    const publicUrl = getPublicUrlFromRequest(request);\r\n    const message = `captured a ${request.method} ${request.url} request without a corresponding request handler.\n\n  If you wish to intercept this request, consider creating a request handler for it:\n\n  rest.${request.method.toLowerCase()}('${publicUrl}', (req, res, ctx) => {\n    return res(ctx.text('body'))\n  })`;\r\n    switch (handler) {\r\n        case 'error': {\r\n            throw new Error(`[MSW] Error: ${message}`);\r\n        }\r\n        case 'warn': {\r\n            console.warn(`[MSW] Warning: ${message}`);\r\n        }\r\n        default:\r\n            return;\r\n    }\r\n}\n\nfunction getAllCookies() {\r\n    return parse_1(document.cookie);\r\n}\r\n/**\r\n * Returns relevant document cookies based on the request `credentials` option.\r\n */\r\nfunction getRequestCookies(req) {\r\n    switch (req.credentials) {\r\n        case 'same-origin': {\r\n            // Return document cookies only when requested a resource\r\n            // from the same origin as the current document.\r\n            return location.origin === req.url.origin ? getAllCookies() : {};\r\n        }\r\n        case 'include': {\r\n            // Return all document cookies.\r\n            return getAllCookies();\r\n        }\r\n        default: {\r\n            return {};\r\n        }\r\n    }\r\n}\n\nconst handleRequestWith = (context, options) => {\r\n    return (event) => __awaiter(void 0, void 0, void 0, function* () {\r\n        const channel = createBroadcastChannel(event);\r\n        try {\r\n            const message = JSON.parse(event.data, function (key, value) {\r\n                if (key === 'url') {\r\n                    return new URL(value);\r\n                }\r\n                // Serialize headers\r\n                if (key === 'headers') {\r\n                    return new lib$1.Headers(value);\r\n                }\r\n                // Prevent empty fields from presering an empty value.\r\n                // It's invalid to perform a GET request with { body: \"\" }\r\n                if (\r\n                // Check if we are parsing deeper in `event.data.payload`,\r\n                // because this custom JSON parser is invoked for each depth level.\r\n                this.method &&\r\n                    isStringEqual(this.method, 'GET') &&\r\n                    key === 'body' &&\r\n                    value === '') {\r\n                    return undefined;\r\n                }\r\n                return value;\r\n            });\r\n            const { type, payload: req } = message;\r\n            // Ignore irrelevant worker message types\r\n            if (type !== 'REQUEST') {\r\n                return null;\r\n            }\r\n            // Parse the request's body based on the \"Content-Type\" header.\r\n            req.body = parseBody(req.body, req.headers);\r\n            // Set document cookies on the request.\r\n            req.cookies = getRequestCookies(req);\r\n            const { response, handler, publicRequest, parsedRequest, } = yield getResponse(req, context.requestHandlers);\r\n            // Handle a scenario when there is no request handler\r\n            // found for a given request.\r\n            if (!handler) {\r\n                onUnhandledRequest(req, options.onUnhandledRequest);\r\n                return channel.send({ type: 'MOCK_NOT_FOUND' });\r\n            }\r\n            // Handle a scenario when there is a request handler,\r\n            // but it doesn't return any mocked response.\r\n            if (!response) {\r\n                console.warn('[MSW] Expected a mocking resolver function to return a mocked response Object, but got: %s. Original response is going to be used instead.', response);\r\n                return channel.send({ type: 'MOCK_NOT_FOUND' });\r\n            }\r\n            const responseWithSerializedHeaders = Object.assign(Object.assign({}, response), { headers: lib$1.headersToList(response.headers) });\r\n            if (!options.quiet) {\r\n                setTimeout(() => {\r\n                    handler.log(publicRequest, responseWithSerializedHeaders, handler, parsedRequest);\r\n                }, response.delay);\r\n            }\r\n            channel.send({\r\n                type: 'MOCK_SUCCESS',\r\n                payload: responseWithSerializedHeaders,\r\n            });\r\n        }\r\n        catch (error) {\r\n            if (error instanceof NetworkError) {\r\n                // Treat emulated network error differently,\r\n                // as it is an intended exception in a request handler.\r\n                return channel.send({\r\n                    type: 'NETWORK_ERROR',\r\n                    payload: {\r\n                        name: error.name,\r\n                        message: error.message,\r\n                    },\r\n                });\r\n            }\r\n            // Treat all the other exceptions in a request handler\r\n            // as unintended, alerting that there is a problem needs fixing.\r\n            channel.send({\r\n                type: 'INTERNAL_ERROR',\r\n                payload: {\r\n                    status: 500,\r\n                    body: JSON.stringify({\r\n                        errorType: error.constructor.name,\r\n                        message: error.message,\r\n                        location: error.stack,\r\n                    }),\r\n                },\r\n            });\r\n        }\r\n    });\r\n};\n\nfunction requestIntegrityCheck(context, serviceWorker) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        // Signal Service Worker to report back its integrity\r\n        serviceWorker.postMessage('INTEGRITY_CHECK_REQUEST');\r\n        const { payload: actualChecksum } = yield context.events.once('INTEGRITY_CHECK_RESPONSE');\r\n        // Compare the response from the Service Worker and the\r\n        // global variable set by webpack upon build.\r\n        if (actualChecksum !== \"65d33ca82955e1c5928aed19d1bdf3f9\") {\r\n            throw new Error(`Currently active Service Worker (${actualChecksum}) is behind the latest published one (${\"65d33ca82955e1c5928aed19d1bdf3f9\"}).`);\r\n        }\r\n        return serviceWorker;\r\n    });\r\n}\n\n/**\r\n * Intercepts and defers any requests on the page\r\n * until the Service Worker instance is ready.\r\n * Must only be used in a browser.\r\n */\r\nfunction deferNetworkRequestsUntil(predicatePromise) {\r\n    // Defer any `XMLHttpRequest` requests until the Service Worker is ready.\r\n    const originalXhrSend = window.XMLHttpRequest.prototype.send;\r\n    window.XMLHttpRequest.prototype.send = function (...args) {\r\n        // Keep this function synchronous to comply with `XMLHttpRequest.prototype.send`,\r\n        // because that method is always synchronous.\r\n        lib.until(() => predicatePromise).then(() => {\r\n            window.XMLHttpRequest.prototype.send = originalXhrSend;\r\n            this.send(...args);\r\n        });\r\n    };\r\n    // Defer any `fetch` requests until the Service Worker is ready.\r\n    const originalFetch = window.fetch;\r\n    window.fetch = (...args) => __awaiter(this, void 0, void 0, function* () {\r\n        yield lib.until(() => predicatePromise);\r\n        window.fetch = originalFetch;\r\n        return window.fetch(...args);\r\n    });\r\n}\n\nconst DEFAULT_START_OPTIONS = {\r\n    serviceWorker: {\r\n        url: '/mockServiceWorker.js',\r\n        options: null,\r\n    },\r\n    quiet: false,\r\n    waitUntilReady: true,\r\n    onUnhandledRequest: 'bypass',\r\n    findWorker: (scriptURL, mockServiceWorkerUrl) => scriptURL === mockServiceWorkerUrl,\r\n};\r\nconst createStart = (context) => {\r\n    /**\r\n     * Registers and activates the mock Service Worker.\r\n     */\r\n    return function start(options) {\r\n        const resolvedOptions = mergeRight(DEFAULT_START_OPTIONS, options || {});\r\n        const startWorkerInstance = () => __awaiter(this, void 0, void 0, function* () {\r\n            if (!('serviceWorker' in navigator)) {\r\n                console.error(`[MSW] Failed to register a Service Worker: this browser does not support Service Workers (see https://caniuse.com/serviceworkers), or your application is running on an insecure host (consider using HTTPS for custom hostnames).`);\r\n                return null;\r\n            }\r\n            // Remove all previously existing event listeners.\r\n            // This way none of the listeners persists between Fast refresh\r\n            // of the application's code.\r\n            context.events.removeAllListeners();\r\n            context.events.addListener(navigator.serviceWorker, 'message', handleRequestWith(context, resolvedOptions));\r\n            const [, instance] = yield lib.until(() => getWorkerInstance(resolvedOptions.serviceWorker.url, resolvedOptions.serviceWorker.options, resolvedOptions.findWorker));\r\n            if (!instance) {\r\n                return null;\r\n            }\r\n            const [worker, registration] = instance;\r\n            if (!worker) {\r\n                if (options === null || options === void 0 ? void 0 : options.findWorker) {\r\n                    console.error(`\\\n[MSW] Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"${resolvedOptions.serviceWorker.url}\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`);\r\n                }\r\n                else {\r\n                    console.error(`\\\n[MSW] Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"${resolvedOptions.serviceWorker.url}\" cannot resolve against the actual public hostname (${location.host}). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`);\r\n                }\r\n                return null;\r\n            }\r\n            context.worker = worker;\r\n            context.registration = registration;\r\n            context.events.addListener(window, 'beforeunload', () => {\r\n                if (worker.state !== 'redundant') {\r\n                    // Notify the Service Worker that this client has closed.\r\n                    // Internally, it's similar to disabling the mocking, only\r\n                    // client close event has a handler that self-terminates\r\n                    // the Service Worker when there are no open clients.\r\n                    worker.postMessage('CLIENT_CLOSED');\r\n                }\r\n                // Make sure we're always clearing the interval - there are reports that not doing this can\r\n                // cause memory leaks in headless browser environments.\r\n                window.clearInterval(context.keepAliveInterval);\r\n            });\r\n            // Check if the active Service Worker is the latest published one\r\n            const [integrityError] = yield lib.until(() => requestIntegrityCheck(context, worker));\r\n            if (integrityError) {\r\n                console.error(`\\\n[MSW] Detected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues\\\n      `);\r\n            }\r\n            // Signal the Service Worker to enable requests interception\r\n            const [activationError] = yield lib.until(() => activateMocking(context, options));\r\n            if (activationError) {\r\n                console.error('Failed to enable mocking', activationError);\r\n                return null;\r\n            }\r\n            context.keepAliveInterval = window.setInterval(() => worker.postMessage('KEEPALIVE_REQUEST'), 5000);\r\n            return registration;\r\n        });\r\n        const workerRegistration = startWorkerInstance();\r\n        // Defer any network requests until the Service Worker instance is ready.\r\n        // This prevents a race condition between the Service Worker registration\r\n        // and application's runtime requests (i.e. requests on mount).\r\n        if (resolvedOptions.waitUntilReady) {\r\n            deferNetworkRequestsUntil(workerRegistration);\r\n        }\r\n        return workerRegistration;\r\n    };\r\n};\n\nconst createStop = (context) => {\r\n    /**\r\n     * Signal the Service Worker to disable mocking for this client.\r\n     * Use this an an explicit way to stop the mocking, while preserving\r\n     * the worker-client relation. Does not affect the worker's lifecycle.\r\n     */\r\n    return function stop() {\r\n        var _a;\r\n        (_a = context.worker) === null || _a === void 0 ? void 0 : _a.postMessage('MOCK_DEACTIVATE');\r\n        context.events.removeAllListeners();\r\n        window.clearInterval(context.keepAliveInterval);\r\n    };\r\n};\n\nfunction use(currentHandlers, ...handlers) {\r\n    currentHandlers.unshift(...handlers);\r\n}\r\nfunction restoreHandlers(handlers) {\r\n    handlers.forEach((handler) => {\r\n        if ('shouldSkip' in handler) {\r\n            handler.shouldSkip = false;\r\n        }\r\n    });\r\n}\r\nfunction resetHandlers(initialHandlers, ...nextHandlers) {\r\n    return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers];\r\n}\n\n// Declare the list of event handlers on the module's scope\r\n// so it persists between Fash refreshes of the application's code.\r\nlet listeners = [];\r\n/**\r\n * Creates a new mock Service Worker registration\r\n * with the given request handlers.\r\n * @param {RequestHandler[]} requestHandlers List of request handlers\r\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker`}\r\n */\r\nfunction setupWorker(...requestHandlers) {\r\n    requestHandlers.forEach((handler) => {\r\n        if (Array.isArray(handler))\r\n            throw new Error(`[MSW] Failed to call \"setupWorker\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).`);\r\n    });\r\n    const context = {\r\n        worker: null,\r\n        registration: null,\r\n        requestHandlers: [...requestHandlers],\r\n        events: {\r\n            addListener(target, event, callback) {\r\n                target.addEventListener(event, callback);\r\n                listeners.push({ event, target, callback });\r\n                return () => {\r\n                    target.removeEventListener(event, callback);\r\n                };\r\n            },\r\n            removeAllListeners() {\r\n                for (const { target, event, callback } of listeners) {\r\n                    target.removeEventListener(event, callback);\r\n                }\r\n                listeners = [];\r\n            },\r\n            once(type) {\r\n                const bindings = [];\r\n                return new Promise((resolve, reject) => {\r\n                    const handleIncomingMessage = (event) => {\r\n                        try {\r\n                            const message = JSON.parse(event.data);\r\n                            if (message.type === type) {\r\n                                resolve(message);\r\n                            }\r\n                        }\r\n                        catch (error) {\r\n                            reject(error);\r\n                        }\r\n                    };\r\n                    bindings.push(context.events.addListener(navigator.serviceWorker, 'message', handleIncomingMessage), context.events.addListener(navigator.serviceWorker, 'messageerror', reject));\r\n                }).finally(() => {\r\n                    bindings.forEach((unbind) => unbind());\r\n                });\r\n            },\r\n        },\r\n    };\r\n    // Error when attempting to run this function in a NodeJS environment.\r\n    if (isNodeProcess()) {\r\n        throw new Error('[MSW] Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for NodeJS environment instead.');\r\n    }\r\n    return {\r\n        start: createStart(context),\r\n        stop: createStop(context),\r\n        use(...handlers) {\r\n            use(context.requestHandlers, ...handlers);\r\n        },\r\n        restoreHandlers() {\r\n            restoreHandlers(context.requestHandlers);\r\n        },\r\n        resetHandlers(...nextHandlers) {\r\n            context.requestHandlers = resetHandlers(requestHandlers, ...nextHandlers);\r\n        },\r\n        printHandlers() {\r\n            context.requestHandlers.forEach((handler) => {\r\n                const meta = handler.getMetaInfo();\r\n                console.groupCollapsed(meta.header);\r\n                console.log(`Declaration: ${meta.callFrame}`);\r\n                console.log('Resolver: %s', handler.resolver);\r\n                if (['rest'].includes(meta.type)) {\r\n                    console.log('Match:', `https://mswjs.io/repl?path=${meta.mask}`);\r\n                }\r\n                console.groupEnd();\r\n            });\r\n        },\r\n    };\r\n}\n\nexport { compose, createResponseComposition, defaultContext, defaultResponse, response, setupWorker };\n"]},"metadata":{},"sourceType":"module"}